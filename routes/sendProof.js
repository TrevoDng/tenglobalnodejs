const { request } = require('http');
const pool = require('../postgres/postgresConfig');

const { sendSms } = require('./twilio/twlio');

 const { getTrancactionReference } = require('../service/proofReference');
 const { sendMail } = require('./email/nodeMail');
const { confirmSms } = require('./twilio/confirmSms');

//create proof table
const sql = "CREATE TABLE IF NOT EXISTS proof (proof_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, username VARCHAR(255), file_url VARCHAR(255), country_name VARCHAR(255), amount DECIMAL(19,2), destination VARCHAR(255), pending_action VARCHAR(255), reference VARCHAR(255), created_on TIMESTAMPTZ, updated_on TIMESTAMPTZ, user_id int)"; 
const notificationSql = `CREATE TABLE IF NOT EXISTS notification (
notification_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
proof_id int,
created_on TIMESTAMPTZ,
read VARCHAR(255),
notification_message VARCHAR(255),
user_id int)`;

pool.query(sql, function (err, result) {
        if (err) {
          console.log("Failed to create proof table!");
          return;
        }
        console.log("Proof table created");
      });

pool.query(notificationSql, function (err, result) {
  if (err) {
    console.log("Failed to create notification table!");
    return;
  }
  console.log("notification table created");
});

const sendProof = async (req, res) => {
  //res.status(200).json({message: "Testing sendProof endpot"});
  
  try {
      const { username, email, country_name, amount, file, destination, pending_action, user_id } = req.body;
    //const reference = await getTrancactionReference.result;
    const reference = await getTrancactionReference().result;
    console.log("reference: "+ reference);
    console.log("sender-email: "+ email);

    const created_on = new Date(Date.now()).toISOString();
    const updated_on = new Date(Date.now()).toISOString();

    //const file_url = "file"; //fileInfo.filePath;
    const file_url = file;
    
    pool.query('INSERT INTO proof (username, file_url, country_name, amount, destination, pending_action, reference, created_on, updated_on, user_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *', 
    [
      username, 
      file_url, 
      country_name, 
      amount,
      destination, 
      pending_action, 
      reference, 
      created_on, 
      updated_on, 
      user_id
    ], 
      (error, results) => {
        if (error) {
          return res.status(400).json({proofError: error.message});
        }

        const proof_id = results.rows[0].proof_id;
        const read = "unread"; 
        const notif_message = `your request to send an amount of R${amount} to ${country_name} is being processed!`;
        const userId = user_id;
        console.log({proof_id: proof_id, read: read, notif_message: notif_message, userId: userId});
      
        pool.query('INSERT INTO notification (proof_id, read, created_on, notification_message, user_id) VALUES ($1, $2, $3, $4, $5) RETURNING *',
          [
            proof_id, 
            read,
            created_on,
            notif_message,
            userId,
          ],
          (notif_err, notif_results) => {
            if (notif_err) {
              return res.status(400).json({proofError: error.message});
              
            }
            console.log(notif_results);
          }
        );

        //send sms
        //confirmSms(req, res);

        //send email
        //sendMail(req, res);

        console.log({proofMessage: `Proof added with ID: ${results.rows[0].proof_id}`});
        return res.status(201).json({proofMessage: `Proof added with ID: ${results.rows[0].id}`});
      });
    } catch (error) {
      console.error({proofError: 'Error sending proof'});
      return res.status(400).json({proofError: 'Error sending proof'});
    }
    
  }

  const getProofById=(req, res)=> {
    const user_id = parseInt(req.params['user_id'])
    console.log(user_id);

    if (user_id) {

      pool.query('SELECT * FROM proof WHERE user_id = $1', [user_id], (error, results) => {
        //const proof = results.rows;
  
        return res.status(200).json(results.rows)
      })
      
    } else {
      console.error("Invalid user_id parameter");
      return res.status(400).send("Bad proof request");
    }
  }

  //admin get proof
  const adminGetProof=(req, res)=> {
    //const user_id = parseInt(req.params['user_id'])
    //console.log(user_id);

    //if (user_id) {

      pool.query('SELECT * FROM proof ORDER BY proof_id ASC', (error, results) => {

        if (error) {
          console.log("failed to get proof")
          return res.status(400).json({proofError: "failed to get proof"})
        }
        //const proof = results.rows;
  
        return res.status(200).json(results.rows)
      })
      
    // } else {
    //   console.error("Invalid user_id parameter");
    //   return res.status(400).send("Bad proof request");
    // }
  }

  module.exports = {
    sendProof,
    getProofById, 
    adminGetProof,
  }